<!DOCTYPE html>
<html lang="en">
<head>
    <title>Three.js example 7</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            background: #000;
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>
<script src="./three.js/three.min.js"></script>
<script src="./js/libs/charsetencoder.min.js"></script>
<script src="./js/libs/ammo.js"></script>
<script src="./js/loaders/TGALoader.js"></script>
<script src="./js/loaders/MMDLoader.js"></script>
<script src="./js/animation/CCDIKSolver.js"></script>
<script src="./js/animation/MMDPhysics.js"></script>
<script src="./libs/mmdparser.min.js"></script>
<script src="./libs/ammo.js"></script>
<script src="./libs/stats.min.js"></script>
<script src="./three.js/TrackballControls.js"></script>

<body>

<div id="hgID"></div>


<script>


    function parseQueryString(url) {
        if (url == "") {
            return {
                "ac":1,
                "id":1,
                "yy":0
            };
        }
        var json = {};
        var arr = url.substr(url.indexOf('?') + 1).split('&');

        arr.forEach(function(item) {
            var tmp = item.split('=');
            json[tmp[0]] = tmp[1];
        });


        if (typeof json['id'] == undefined || typeof json['id'] == null) {
            json["id"] = 1;
        }

        if (typeof json['ac'] == undefined || typeof json['ac'] == null) {
            json["ac"] = 1;
        }

        return json;
    }

    

    var container, stats;

    var mesh, camera, scene, renderer;
    var helper;

    var controls;

    var x = 0, y = 0, dx = 0, dy = 0;

    var clock = new THREE.Clock();


    function init() {

        container = document.createElement('div');
        document.body.appendChild(container);

        // PerspectiveCamera方法根据 fov, aspect, near, far 生成透视投影相机.PerspectiveCamera对象的功能函数
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 300);
        camera.position.z = 50;

        scene = new THREE.Scene();
        controls = new THREE.TrackballControls( camera );

        var ambient = new THREE.AmbientLight(0xcccccc);
        scene.add(ambient);

       var light = new THREE.DirectionalLight(0x887766);
       light.position.set(-1, 20, 0);
       light.rotation.x  += Math.PI / 2;
       light.castShadow = true;
       scene.add(light);

        var plane = new THREE.Mesh(
            new THREE.CubeGeometry(20, 20, 1),
            new THREE.MeshLambertMaterial({color: 0xffffff})
        );
        plane.position.set(0, -10.5, 0);
        plane.rotation.x += Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);
        //抗锯齿，背景黑色
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.shadowMap.enabled = true;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(new THREE.Color(0x00000)); // 初始化背景颜色
        container.appendChild(renderer.domElement);

        var onProgress = function (xhr) {
            if (xhr.lengthComputable) {
                var percentComplete = xhr.loaded / xhr.total * 100;
            }
        };
        var onError = function (xhr) {};

        // 模型的路径
        var modle = {
            1 : "corico/corico.pmd",
            2 : "Easterbunny/EasterBunny.pmd",
            3 : "Alparka.pmx",
            4 : "BunnyPajamas.pmx",
            5 : "Crane/Crane.pmx",
            6 : "Kasha/Kasha.pmx",
            7 : "Polka/Polka.pmx",
            8 : "Wedding/Wedding.pmx",
            9 : "Originator/Originator.pmx",
            10 : "Hood/Hood.pmx",
            11 : "Floral/Floral.pmx",
            12 : "jihouchan/jihouchan.pmd",
            13 : "Holiday/Holiday.pmx",
            14 : "Guilty/Guilty.pmx",
        };

        // 模型的动作
        var action = {
            1 :  ['./Action/wavefile_v2.vmd'],
            2 :  ['./Action/xiongmao.vmd'],
            3 :  ['./Action/3.vmd'],
            4 :  ['./Action/4.vmd'],
            5 :  ['./Action/5.vmd'],
            6 :  ['./Action/6.vmd'],
            7 :  ['./Action/7.vmd'],
            8 :  ['./Action/8.vmd'],
            9 :  ['./Action/9.vmd'],
            10 :  ['./Action/10.vmd'],
            11 :  ['./Action/11.vmd'],
            12 :  ['./Action/12.vmd'],
            13 :  ['./Action/13.vmd'],
            14 :  ['./Action/14.vmd'],
            15 :  ['./Action/15.vmd'],
            16 :  ['./Action/16.vmd'],
            17 :  ['./Action/17.vmd'],
            18 :  ['./Action/18.vmd'],
            19 :  ['./Action/19.vmd'],
            20 :  ['./Action/20.vmd'],
            21 :  ['./Action/21.vmd'],
        };

        var obj = parseQueryString(location.search);

        if (typeof obj["id"] == undefined) {
             obj["id"] = 1;
        }

        if (typeof obj["ac"] == undefined) {
            obj["ac"] = 1;
        }

        var modelName = modle[obj["id"]];

        // if (modelName.indexOf('pmx') != -1) {

        //     modelFile = 'https://github.com/hgonlywj/vRsourse/blob/master/' + modelName;

        // } else {

        //     modelFile = "./Model/" + modelName;
        // }
        
        modelFile = "./Model/" + modelName;
        vmdFiles = action[obj["ac"]];

        console.log(obj, " \n", "modelFile = ", modelFile, " \n vmdFiles = ", vmdFiles );

        helper = new THREE.MMDHelper(renderer);
        loader = new THREE.MMDLoader();

        loader.load(modelFile, vmdFiles, function (object) {

            mesh = object;
            mesh.position.y = -10;
            helper.add(mesh);
            helper.setAnimation(mesh);
            helper.setPhysics(mesh);
            helper.unifyAnimationDuration({afterglow: 2.0});
            mesh.castShadow = true;
            mesh.children.forEach(function (item) {
                item.castShadow = true;
            });

            scene.add(mesh);
            if (mesh) {
                for (var i = 0; i < mesh.geometry.animations.length; i++) {
                    clip = mesh.geometry.animations[i];
                    action = mesh.mixer.clipAction(clip);

                    action.time = 1000;
                    action.play();
                    // console.log(action);
                }
            };

            try {
                if (typeof obj['yy'] != undefined && obj['yy'] == '1') {            
                   var audio = new Audio('./miku.mp3');
                   audio.onended = function(){
                       setTimeout(function(){
                           audio.play();
                       }, 5750);
                   };

                   setTimeout(function(){
                           audio.play();
                   }, 5050);
                } 
            } catch (error) {
                ;
            }


        }, onProgress, onError);

        var isDown = false;
        document.addEventListener('mousemove', function (e) {
            if (!isDown)return;
            dx = e.clientX - x;
            dy = e.clientY - y;

            x = e.clientX;
            y = e.clientY;
        });
        document.addEventListener('mousedown', function (e) {
            isDown = true;
            x = e.clientX;
            y = e.clientY;
        });
        document.addEventListener('mouseup', function () {
            isDown = false;
            dx = dy = 0;
        });

        // initRoom();
        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        // 如果不在意多久重绘一次，可以使用requestAnimationFrame方法。它告诉浏览器在合适的时候调用指定函数，通常可能达到60FPS。
        requestAnimationFrame(animate);

        render();
    }

    var onceTime = true;
    function render() {
        controls.update();

        camera.position.x -= dx * .5;
        camera.position.y -= dy * .5;
        camera.lookAt(scene.position);

        if (mesh) {
            var clockTime = clock.getDelta();
            var countTime = parseInt(clock.elapsedTime);
            var count = countTime%15;
            // console.log("count = ", count);

            // if (count == 0 && countTime != 0) {
            //     if (onceTime == true) {
            //         onceTime = false;
            //         for (var i = 0; i < mesh.geometry.animations.length; i++) {
            //             clip = mesh.geometry.animations[i];
            //             action = mesh.mixer.clipAction(clip);
            //             action.time = 1000;
            //             action.play();
            //         }
            //         console.log("change  1000");
            //     }
            // } else {
            //     onceTime = true;
            // }

            helper.animate(clockTime);
            helper.render(scene, camera);

        } else {
            renderer.clear();
        }
    }

    //    setInterval(function () {
    //        console.log(JSON.stringify(clock));
    //    }, 1000);

    window.addEventListener('click', onWindowClick, false);

    //    var singal = true;     // 默认开启
    //    function onWindowClick(e) {
    //        console.log("onWindowClick");
    //        if (singal == true) {
    //            singal = false;
    //            for (var i = 0; i < mesh.geometry.animations.length; i++) {
    //                clip = mesh.geometry.animations[i];
    //                action = mesh.mixer.clipAction(clip);
    //                console.log("singal == true");
    //                action.stop();
    ////               action.enabled = false;
    //            }
    //
    //        } else {
    //            singal = true;
    //            for (var i = 0; i < mesh.geometry.animations.length; i++) {
    //                clip = mesh.geometry.animations[i];
    //                action = mesh.mixer.clipAction(clip);
    //                console.log("singal == false");
    ////                action.startAt(10000);
    ////                action.enabled = true;
    //                action.time = 1000;
    //                action.play();
    //            }
    //        }
    //    }

    function onWindowClick(e) {
        console.log("dblclick");
        for (var i = 0; i < mesh.geometry.animations.length; i++) {
            clip = mesh.geometry.animations[i];
            action = mesh.mixer.clipAction(clip);
            console.log("singal == false");
            action.time = 500;
            action.play();
        }
    }

    window.addEventListener( 'resize', onWindowResize, false );
    function onWindowResize( event ) {

        WIDTH = window.innerWidth;
        HEIGHT = window.innerHeight;

        windowHalfX = WIDTH / 2;
        windowHalfY = HEIGHT / 2;

        renderer.setSize( WIDTH, HEIGHT );

        camera.aspect = WIDTH / HEIGHT;
        camera.updateProjectionMatrix();

    }

    function initRoom() {

        var size = 50;
        var geometry = new THREE.PlaneBufferGeometry( size, size );
        var material = new THREE.MeshPhongMaterial( { color: 0x222222, specular: 0x222222, shininess: 75 } );

        var room = new THREE.Object3D();
        room.position.y = size / 2 - 10;

        // top
        var mesh = new THREE.Mesh( geometry, material );
        mesh.rotation.x = Math.PI/2;
        mesh.position.y = size / 2;
        room.add( mesh );

        // bottom
        mesh = new THREE.Mesh( geometry, material );
        mesh.rotation.x = -Math.PI/2;
        mesh.position.y = -size / 2;
        room.add( mesh );

        // left
        mesh = new THREE.Mesh( geometry, material );
        mesh.position.x = -size / 2;
        mesh.rotation.y = Math.PI/2;
        room.add( mesh );

        // right
        mesh = new THREE.Mesh( geometry, material );
        mesh.position.x = size / 2;
        mesh.rotation.y = -Math.PI/2;
        room.add( mesh );

        // back
        mesh = new THREE.Mesh( geometry, material );
        mesh.position.z = -size / 2;
        room.add( mesh );

        scene.add( room );
    }


    init();
    animate();

</script>

</body>
</html>